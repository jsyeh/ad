int N=6;//vertex number頂點數量
PVector [] gradient=new PVector[N];
PVector [] pos=new PVector[N];
float d0=100, angle0=radians(0); 
boolean bSolving=false;
void setup(){
  size(500,500);
  for(int i=0;i<N;i++){
    pos[i]=new PVector(random(500),random(500));
    gradient[i]=new PVector();
  }
}
void myLine(PVector p1, PVector p2){
  line(p1.x,p1.y,p2.x,p2.y);
}
int [][]a={
  {-1,1,0,0,0},
  {0,-1,1,0,0},
  {0,0,-1,1,0},
  {0,0,0,-1,1} };
float Ci(int i, PVector [] pos){
  PVector ans=new PVector();
  for(int j=0;j<5;j++){//TODO: 變成N
    float w=a[i][j];
    ans.add( PVector.mult(pos[j], w) );
  }
  return ans.magSq()-d0*d0;
}
//float C1(PVector [] pos){//input: 3*pos
//  PVector v1 = PVector.sub(pos[1],pos[0]);
//  return v1.magSq()-d0*d0;
//}
//float C2(PVector [] pos){
//  PVector v2 = PVector.sub(pos[2],pos[1]);
//  return v2.magSq()-d0*d0;
//}
int [][]b={
  {1,0,2,1},
  {2,1,3,2},
  {3,2,4,3}
};
float Cbendi(int i, PVector [] pos){
  PVector v1=PVector.sub(pos[ b[i][0] ],pos[ b[i][1] ]);
  PVector v2=PVector.sub(pos[ b[i][2] ],pos[ b[i][3] ]);
  return PVector.angleBetween(v1,v2)-angle0;
}
//float Cbend(PVector[] pos){//acos() in the future
//  PVector v1=PVector.sub(pos[1],pos[0]);
//  PVector v2=PVector.sub(pos[2],pos[1]);
//  return PVector.angleBetween(v1,v2)-angle0;
//}
//float Canother(int Cj){
//  return Ci(Cj, pos);
//}
float C(int Cj){
  if(Cj==0) return Ci(0,pos);//C1(pos);
  if(Cj==1) return Ci(1,pos);//C2(pos);
  if(Cj==2) return Ci(2,pos);
  if(Cj==3) return Ci(3,pos);

  if(Cj==4) return Cbendi(0,pos);//Cbend(pos);
  if(Cj==5) return Cbendi(1,pos);
  if(Cj==6) return Cbendi(2,pos);
  return 0;
}
void calcGradient(int Cj, int Xi){//input:第幾個constraint, 第幾個點
  float d=0.001;//for gradient distance
  float f1, f0;
  pos[Xi].x+=d;
  f1=C(Cj);
  pos[Xi].x-=d*2;
  f0=C(Cj);
  pos[Xi].x+=d;
  gradient[Xi].x=(f1-f0)/2/d;

  pos[Xi].y+=d;
  f1=C(Cj);
  pos[Xi].y-=d*2;
  f0=C(Cj);
  pos[Xi].y+=d;
  gradient[Xi].y=(f1-f0)/2/d;

  pos[Xi].z+=d;
  f1=C(Cj);
  pos[Xi].z-=d*2;
  f0=C(Cj);
  pos[Xi].z+=d;
  gradient[Xi].z=(f1-f0)/2/d;
}
void solver(){//Input: pos*3
  float maxMag=0;
  float []w=new float[N];//{0.2,0.2,0.2,0.2,0.2};//0.33333, 0.33333, 0.33333};
  for(int i=0;i<N;i++) w[i]=1.0/N;
  for(int Cj=0; Cj<7; Cj++){
    //partial gradient C[?]
    for(int Xi=0;Xi<N;Xi++){
      calcGradient(Cj, Xi);
    }
    float gradientSum=0;
    for(int Xi=0;Xi<N;Xi++){
      gradientSum += w[Xi]*gradient[Xi].magSq();
    }
    float lambda = C(Cj)/gradientSum;
    for(int Xi=0;Xi<N;Xi++){  //更新
      PVector diff=PVector.mult(gradient[Xi], -lambda*w[Xi]);
      pos[Xi].add(diff);
      if(diff.mag()>maxMag) maxMag=diff.mag();
    }
  }
  if(maxMag<1) bSolving=false;//距離夠小,就停止計算
}
void draw(){
  if(bSolving){
    solver();
  }
  background(128);
  myLine(pos[0],pos[1]);
  myLine(pos[1],pos[2]);
  myLine(pos[2],pos[3]);
  myLine(pos[3],pos[4]);
  for(int i=0;i<N;i++){
    if(i==N-1) fill(255,0,0);
    else fill(255);
    ellipse(pos[i].x, pos[i].y, 20,20);
  }
}
void mousePressed(){
  bSolving=true;
}
